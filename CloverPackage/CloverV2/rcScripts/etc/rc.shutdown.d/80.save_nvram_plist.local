#!/bin/bash

#
# 2017 (c) syscl/lighting/Yating Zhou
# dump NVRAM for Clover
#
# note: msdosfs.kext, exfat.kext should be loaded
#

#================================= GLOBAL VARS ==================================

#
# Script version info
#
gScriptVersion=1.4

#
# The script expects '0.5' but non-US localizations use '0,5' so we export
# LC_NUMERIC here (for the duration of the deploy.sh) to prevent errors.
#
export LC_NUMERIC="en_US.UTF-8"

#
# Prevent non-printable/control characters
#
unset GREP_OPTIONS
unset GREP_COLORS
unset GREP_COLOR

#
# Define two status: 0 - Success, Turn on,
#                    1 - Failure, Turn off
#
kBASHReturnSuccess=0
kBASHReturnFailure=1

#
# Located repository
#
gRepo=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

#
# Source clover rc library if needed
#
if [[ ! "$(type -t GetNVRamKey)" == "function" ]]; then
    source "${gRepo}"/../rc.clover.lib
fi

#
# Variables
#
gNVRAMf=nvram.plist
gNVRAMbuff=$(nvram -x -p)
gDisk=($(ls /dev/disk[0-9] |grep -i -o "disk[0-9]"))
gRootInf=$(df -l |grep -i -v "/Volumes" |grep -i -o "disk[0-9]s[0-9]")
gESPList=""
RETURN_VAL=${kBASHReturnSuccess}
#
# we write this truncate name for more flexible situation
#
gEmuVariableName=EmuVariable
gEmuVariablePresent=$(nvram -x -p |grep -i "${gEmuVariableName}")
gNvramLogPath="${CLOVER_LOG_LOCATION}/rc.shutdown.log"

# Debug mode ?
[[ "$DEBUG" -ne 0 ]] && set -x

#
#--------------------------------------------------------------------------------
#

function _toLowerCase()
{
    echo "`echo $1 | tr '[:upper:]' '[:lower:]'`"
}

#
#--------------------------------------------------------------------------------
#

function _fndESP()
{
    #
    # find all EFI partitions distrubuted in different disks
    #
    # default gNVRAMf save path should be EFI as Clover's new feature
    #
    local gEfiIDENTIFIER=""
    local gEfiUID="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
    local gPartIndex=""
    for ((i=0; i<${#gDisk[@]}; ++i))
    do
      gPartIndex=$(gpt -r show "/dev/${gDisk[i]}" |grep -i "${gEfiUID}" |awk '{print $3}')
      case "${gPartIndex}" in
      [[:digit:]]* ) echo "Found EFI ${gDisk[i]}s${gPartIndex}"
                     gESPList[$i]="${gDisk[i]}s${gPartIndex}"
                     ;;
      *            )
                     ;;
      esac
    done
}

#
#--------------------------------------------------------------------------------
#

function _mountESP()
{
    #
    # mount EFI partition return mount point
    #
    local gESP=$1
    local gDevRepo="/dev/${gESP}"
    local gESPFsType=""

    #
    # get umount error information
    #
    local gUmountMPErr=""
    local gDevUmountErr=""
    local gMountPointf=""
    #
    # syscl: use EFIXY(diskXsY) as MountPoint can ensure uniqueness
    #
    # EFI01 - disk0s1 EFI11 - disk1s1 ...
    #
    local gAssignMountPoint="/Volumes/EFI${gESP:4:1}${gESP:6:1}"

    #
    # unmount the mount point(/Volumes/EFIXY) and device(/dev/diskXsY) first just in case
    #
    gUmountMPErr=$(umount ${gAssignMountPoint} 2>&1)
    gDevUmountErr=$(umount ${gDevRepo} 2>&1)
    if [[ ${gDevUmountErr} == *"diskutil unmount"* ]]; then
        echo "Device mount error ${gDevUmountErr}"   >>${gNvramLogPath}
        echo "Now use diskutil umount to release it" >>${gNvramLogPath}
        gDevUmountErr=$(diskutil umount ${gDevRepo} 2>&1)
        echo "diskutil: ${gDevUmountErr}"            >>${gNvramLogPath}
    fi
    #
    # remove /Volumes/EFIXY folder just in case
    #
    if [ -d ${gAssignMountPoint} ]; then
        gMountPointf=$(ls ${gAssignMountPoint} 2>&1)
        if [ -z ${gMountPointf} ]; then
            rm -r ${gAssignMountPoint}  2>/dev/null
        fi

        if [[ ${gMountPointf} == ${gNVRAMf} ]]; then
            rm -r ${gAssignMountPoint}  2>/dev/null
        fi
    fi
    #
    # create mount root
    #
    mkdir ${gAssignMountPoint}  2>/dev/null
    #
    # Try to mount ESP
    #
    for gFsType in msdos hfs exfat;
    do
      case "$(_toLowerCase ${gFsType})" in
      *hfs* ) #
              # HFS+, use mount_hfs directly
              #
              mount_hfs "${gDevRepo}" "${gAssignMountPoint}"           &>/dev/null && RETURN_VAL=${kBASHReturnSuccess} || RETURN_VAL=${kBASHReturnFailure}
              ;;

      *     ) #
              # Fat32 or exFat
              #
              mount -t ${gFsType} "${gDevRepo}" "${gAssignMountPoint}" &>/dev/null && RETURN_VAL=${kBASHReturnSuccess} || RETURN_VAL=${kBASHReturnFailure}
              ;;
      esac

      if [ "${RETURN_VAL}" == ${kBASHReturnSuccess} ]; then
          #
          # current ESP filesystem type store here
          #
          gESPFsType=${gFsType}
      fi
    done

    if [ -z ${gESPFsType} ]; then
        #
        # Fail, return "/"
        #
        echo "/"
      else
        #
        # OK, return mount point
        #
        echo ${gAssignMountPoint}
    fi
}

#
#--------------------------------------------------------------------------------
#

function _dmpNVRAM()
{
    #
    # dump NVRAM to target location
    #
    local gTarPath=$1
    local gTarEFIDENTIFIER=$2

    #
    # one more step to see if dump NVRAM is required
    #
    if [[ ${gTarPath} != "/" ]]; then
        if [[ ${gTarEFIDENTIFIER:4:1} == ${gRootInf:4:1} ]]; then
            #
            # nvram.plist should be in either EFI/ or /
            #
            if [ -f "/${gNVRAMf}" ]; then
                rm /${gNVRAMf}
            fi
          else
            #
            # EFI, check if there's Clover
            #
            if [ ! -d ${gTarPath}/EFI/Clover ]; then
                #
                # no Clover, return
                #
                echo "No Clover on ${gTarPath}, return"
                return ${kBASHReturnFailure}
            fi
        fi
    fi
    #
    # dump to NVRAM now
    #
    local gOldNVRAM=$(cat ${gTarPath}/${gNVRAMf} 2>&1)
    if [[ "${gOldNVRAM}" != "${gNVRAMbuff}" ]]; then
        #
        # Need to refresh
        #
        nvram -x -p >"${gTarPath}/${gNVRAMf}" 2>&1 && RETURN_VAL=${kBASHReturnSuccess} || RETURN_VAL=${kBASHReturnFailure}
    fi
}

#==================================== START =====================================

echo "v${gScriptVersion} (c) 2017 syscl/lighting/Yating Zhou" >${gNvramLogPath}
#
# find EFIs, added into gESPList
#
_fndESP                                                      >>${gNvramLogPath}

#
# mount EFIs then dump NVRAM to target path
#
for ((i=0; i<${#gDisk[@]}; ++i))
do
  gTargetPath=$(_mountESP ${gESPList[i]})
  echo "Target path: ${gTargetPath}"                         >>${gNvramLogPath}

  if [ ! -z ${gEmuVariablePresent} ]; then
      echo "EmuVariable is present"                          >>${gNvramLogPath}
      #
      # dump NVRAM to target path now
      #
      echo "dump nvram"                                      >>${gNvramLogPath}
      _dmpNVRAM ${gTargetPath} ${gESPList[i]}                >>${gNvramLogPath}
  fi
done

#================================================================================

exit ${RETURN_VAL}
